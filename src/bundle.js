/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/front_end/main.ts":
/*!*******************************!*\
  !*** ./src/front_end/main.ts ***!
  \*******************************/
/***/ (() => {

eval("\nconsole.log('Isometric');\nconst elementIds = ['canvas', 'toggleGrid'];\nconst GetElements = () => {\n    const elements = Object.fromEntries(elementIds.map(id => [id, document.getElementById(id)]));\n    const nullElements = Object.keys(elements).filter(id => elements[id] === null);\n    if (nullElements.length > 0) {\n        throw new Error(`Failed to find all elements by id ${nullElements}`);\n    }\n    return elements;\n};\nconst LoadImage = async (src) => {\n    const image = new Image();\n    image.src = src;\n    return new Promise((resolve, reject) => {\n        image.onload = () => resolve(image);\n        image.onerror = err => reject(new Error(`Failed to load image at ${src}`));\n    });\n};\nclass PerlinNoise {\n    p;\n    permutation;\n    constructor() {\n        // Initialize the permutation table\n        this.p = [];\n        for (let i = 0; i < 256; i++) {\n            this.p[i] = Math.floor(Math.random() * 256);\n        }\n        // Duplicate the permutation table\n        this.permutation = [];\n        for (let i = 0; i < 256; i++) {\n            this.permutation[i] = this.p[i % 256];\n        }\n    }\n    // Fade function to smooth the interpolation\n    fade(t) {\n        return t * t * t * (t * (t * 6 - 15) + 10);\n    }\n    // Dot product of the gradient and the distance vector\n    grad(hash, x, y) {\n        const h = hash & 15; // Determine which gradient to use\n        const u = h < 8 ? x : y;\n        const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;\n        return (h & 1 ? -u : u) + (h & 2 ? -v : v);\n    }\n    // Perlin noise function for 2D\n    noise(x, y) {\n        const X = Math.floor(x) & 255; // Calculate grid cell coordinates\n        const Y = Math.floor(y) & 255;\n        x -= Math.floor(x); // Relative position in grid cell\n        y -= Math.floor(y);\n        const u = this.fade(x); // Fade the x coordinate\n        const v = this.fade(y); // Fade the y coordinate\n        // Hash coordinates of the 4 corners\n        const a = this.permutation[X] + Y;\n        const aa = this.permutation[a];\n        const ab = this.permutation[a + 1];\n        const b = this.permutation[X + 1] + Y;\n        const ba = this.permutation[b];\n        const bb = this.permutation[b + 1];\n        // Interpolate between gradients at the four corners\n        const x1 = this.lerp(this.grad(aa, x, y), this.grad(ba, x - 1, y), u);\n        const x2 = this.lerp(this.grad(ab, x, y - 1), this.grad(bb, x - 1, y - 1), u);\n        return this.lerp(x1, x2, v); // Final interpolation\n    }\n    // Linear interpolation function\n    lerp(a, b, t) {\n        return a + t * (b - a);\n    }\n    noise2 = (x, y) => {\n        const octaves = 4;\n        let total = 0;\n        let frequency = 1;\n        let amplitude = 1;\n        for (let i = 0; i < octaves; i++) {\n            total += this.noise(x * frequency, y * frequency) * amplitude;\n            frequency *= 2;\n            amplitude *= 0.5;\n        }\n        return total;\n    };\n}\nconst Renderer = async () => {\n    const canvas = elements.canvas;\n    // Initialise\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n        throw new Error('Failed to get 2D context');\n    }\n    const [width, height] = [canvas.width, canvas.height];\n    ctx.imageSmoothingEnabled = false;\n    const scale = 4;\n    const sts = 16; // source tile size\n    const dts = sts * scale; // destination tile size\n    const image = await LoadImage('assets/Isometric_MedievalFantasy_Tiles.png');\n    const entities = await LoadImage('assets/IsometricTRPGAssetPack_OutlinedEntities.png');\n    const mapIndicators = await LoadImage('assets/IsometricTRPGAssetPack_MapIndicators2.png');\n    // Member Functions\n    const DrawLine = (x0, y0, x1, y1) => {\n        ctx.beginPath();\n        ctx.moveTo(x0, y0);\n        ctx.lineTo(x1, y1);\n        ctx.stroke();\n    };\n    const DrawIsometricGrid = () => {\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = 'hsla(0, 0%, 50%, 0.5)';\n        for (let x = 0; x < width; x += dts) {\n            DrawLine(x, 0, x, height);\n        }\n        for (let y = 0; y < height; y += dts) {\n            DrawLine(0, y, width, y);\n        }\n        ctx.strokeStyle = 'hsl(0, 0%, 100%, 0.5)';\n        for (let x = dts / 2; x < width; x += dts) {\n            DrawLine(x, 0, x, height);\n        }\n        for (let y = dts / 2; y < height; y += dts) {\n            DrawLine(0, y, width, y);\n        }\n        for (let y = -dts; y < height; y += dts) {\n            for (let x = -dts; x < width; x += dts) {\n                ctx.strokeStyle = 'hsla(200, 100%, 80%, 0.5)';\n                DrawLine(x, y, x + 2 * dts, y + dts);\n                ctx.strokeStyle = 'hsla(100, 100%, 80%, 0.5)';\n                DrawLine(x, y + dts, x + 2 * dts, y);\n            }\n        }\n    };\n    const heightOverflow = 1; // pixel\n    const WorldToCanvasPosition = ({ x, y, z }) => {\n        const p0 = {\n            // destination x & y origin (centre)\n            x: (width - dts) / 2,\n            y: (height - dts) / 2 - heightOverflow * scale\n        };\n        const p = {\n            x: p0.x - (x * dts) / 2 + (y * dts) / 2,\n            y: p0.y + (x * dts) / 4 + (y * dts) / 4 - (z * dts) / 2\n        };\n        return p;\n    };\n    const CanvasToWorldPosition = ({ cx, cy, wz }) => {\n        // EQ.1\n        // _x =  p0.x - (x * dts) / 2 + (y * dts) / 2,\n        // 2/dts * (_x - p0.x)  = - x + y\n        // EQ.2\n        // _y = p0.y + (x * dts) / 4 + (y * dts) / 4 - (z * dts) / 2\n        // 4/dts * (_y - p0.y) + 2*z = x + y\n        // 2*y = EQ.1 + EQ.2\n        // 2*y = 2/dts * (_x - p0.x) + 4/dts * (_y - p0.y) + 2*z\n        // y =  1/dts * (_x - p0.x) + 2/dts * (_y - p0.y) + z\n        // y = 1/dts * (_x - p0.x + 2 * (_y - p0.y)) + z\n        // 2*x = - EQ.1 + EQ.2\n        // 2*x = - 2/dts * (_x - p0.x) + 4/dts * (_y - p0.y) + 2*z\n        // x = - 1/dts * (_x - p0.x) + 2/dts * (_y - p0.y) + z\n        // x = 1/dts * (p0.x - _x + 2 * (_y - p0.y)) + z\n        const [sw, sh] = [sts, sts + heightOverflow];\n        cx = cx - dts / 2;\n        cy = cy - dts / 2;\n        const p0 = {\n            // destination x & y origin (centre)\n            x: (width - dts) / 2,\n            y: (height - dts) / 2 - heightOverflow * scale\n        };\n        const p = {\n            x: (1 / dts) * (p0.x - cx + 2 * (cy - p0.y)) + wz + 0.5,\n            y: (1 / dts) * (cx - p0.x + 2 * (cy - p0.y)) + wz + 0.5\n        };\n        return p;\n    };\n    const DrawIsometricTile = (wx, wy, wz, ti, tj, image) => {\n        //  /  \\\n        // x    y\n        // w = world x, y & z\n        // ti, tj = tile index in x & y\n        const [sw, sh] = [sts, sts + heightOverflow]; // source width & height (+1 = tile overflow)\n        const [sx, sy] = [ti * sw, tj * sh]; // source x & y\n        const [dw, dh] = [sw * scale, sh * scale]; // destination width & height\n        const [dx0, dy0] = [\n            // destination x & y origin (centre)\n            (width - dts) / 2,\n            (height - dts) / 2 - heightOverflow * scale\n        ];\n        const [dx, dy] = [\n            // destination x & y\n            dx0 - (wx * dts) / 2 + (wy * dts) / 2,\n            dy0 + (wx * dts) / 4 + (wy * dts) / 4 - (wz * dts) / 2\n        ];\n        const d = WorldToCanvasPosition({ x: wx, y: wy, z: wz });\n        ctx.drawImage(image, sx, sy, sw, sh, d.x, d.y, dw, dh);\n    };\n    const tileMap = {\n        dirt: { x: 0, y: 0 },\n        grass: { x: 1, y: 0 },\n        stone: { x: 2, y: 0 },\n        sand: { x: 3, y: 0 },\n        water: { x: 7, y: 0 },\n        plant: { x: 10, y: 0 },\n        cactus: { x: 8, y: 1 },\n        log: { x: 8, y: 3 },\n        canopy: { x: 7, y: 3 },\n        dryGrass: { x: 3, y: 2 },\n        smallStones: { x: 8, y: 0 },\n        largeStones: { x: 9, y: 0 },\n        lava: { x: 2, y: 3 }\n    };\n    const GenerateTiles = () => {\n        const perlin = new PerlinNoise();\n        const perlin2 = new PerlinNoise();\n        const n = 12;\n        const positions = [];\n        for (let y = -n; y <= n; y += 1) {\n            for (let x = -n; x <= n; x += 1) {\n                positions.push({ x, y });\n            }\n        }\n        // console.log(positions)\n        positions.sort((a, b) => {\n            const aw = a.x + a.y;\n            const bw = b.x + b.y;\n            return aw - bw;\n        });\n        const tiles = [];\n        const offset = n;\n        for (const p of positions) {\n            let frequency = 16;\n            const z = perlin.noise2((p.x + offset) / frequency, (p.y + offset) / frequency);\n            frequency = 8;\n            const z2 = perlin2.noise2((p.x + offset) / frequency, (p.y + offset) / frequency);\n            let tilename = 'grass';\n            //   console.log(z)\n            const borderDistance = 8 + z2;\n            if (Math.abs(p.x) > borderDistance || Math.abs(p.y) > borderDistance) {\n                tilename = 'water';\n            }\n            else if (z < -0.2) {\n                tilename = 'water';\n            }\n            else if (z < -0.1) {\n                tilename = 'sand';\n            }\n            else if (z < 0) {\n                tilename = 'dirt';\n            }\n            else if (z < 0.2) {\n                tilename = 'dryGrass';\n            }\n            else if (z < 0.4) {\n                tilename = 'grass';\n            }\n            else if (z < 0.7) {\n                tilename = 'stone';\n            }\n            else if (z < 1.0) {\n                tilename = 'lava';\n            }\n            let t = tileMap[tilename];\n            // const z = Math.floor(Math.random() < 1.0 ? 0 : 1)\n            //   const tx = Math.floor(\n            //     Math.pow((perlin.noise2(p.x / n, p.y / n) + 1) / 2, 2) * 5\n            //   )\n            //   const z = 1 + Math.floor(perlin.noise2(p.x / n + 1, p.y / n + 1))\n            // console.log(p.x, p.y, )\n            //   const tx = Math.floor(Math.pow(Math.random(), 3) * 5)\n            let wz = 0;\n            if (tilename === 'water') {\n                wz = 0;\n            }\n            else if (z < 0.2) {\n                wz = 0;\n            }\n            else if (z < 0.4) {\n                wz = 1;\n            }\n            else if (z < 1.0) {\n                wz = 2;\n            }\n            for (let zz = 0; zz <= wz; zz++) {\n                tiles.push({ position: p, z: zz, tx: t.x, ty: t.y });\n            }\n            if (tilename === 'grass') {\n                const r = Math.random();\n                if (r < 0.1) {\n                    t = tileMap['plant'];\n                    tiles.push({ position: p, z: wz + 1, tx: t.x, ty: t.y });\n                }\n                else if (r < 0.15) {\n                    t = tileMap['log'];\n                    tiles.push({ position: p, z: wz + 1, tx: t.x, ty: t.y });\n                    t = tileMap['canopy'];\n                    tiles.push({ position: p, z: wz + 2, tx: t.x, ty: t.y });\n                }\n                else if (z > 0.3 && Math.random() > 0.9) {\n                    t = tileMap['smallStones'];\n                    tiles.push({ position: p, z: wz + 1, tx: t.x, ty: t.y });\n                }\n            }\n            else if (tilename === 'sand' && Math.random() > 0.9) {\n                t = tileMap['cactus'];\n                tiles.push({ position: p, z: wz + 1, tx: t.x, ty: t.y });\n            }\n            else if (tilename === 'stone' && Math.random() > 0.95) {\n                t = tileMap['largeStones'];\n                tiles.push({ position: p, z: wz + 1, tx: t.x, ty: t.y });\n            }\n        }\n        // console.log(tiles)\n        return tiles;\n    };\n    let cursorWorldPosition = null;\n    const RenderLoop = (time, tiles) => {\n        ctx.clearRect(0, 0, width, height);\n        for (const t of tiles) {\n            DrawIsometricTile(t.position.x, t.position.y, t.z, t.tx, t.ty, image);\n        }\n        if (cursorWorldPosition !== null) {\n            //   console.log('here2', cursorWorldPosition)\n            //   console.log(cursorWorldPosition)\n            DrawIsometricTile(cursorWorldPosition.x, cursorWorldPosition.y, cursorWorldPosition.z, 0, 0, mapIndicators);\n        }\n        DrawIsometricTile(0, 0, 1, time % 1000 < 500 ? 0 : 1, 0, entities);\n        // DrawIsometricTile(0, 0, 0, 0, 0, image)\n        if (showGrid) {\n            DrawIsometricGrid();\n        }\n        requestAnimationFrame(time => {\n            RenderLoop(time, tiles);\n        });\n    };\n    const tiles = GenerateTiles();\n    canvas.addEventListener('mousemove', (event) => {\n        const m = { x: event.offsetX, y: event.offsetY };\n        cursorWorldPosition = null;\n        for (let wz = 1; wz >= 0; wz--) {\n            let w = CanvasToWorldPosition({ cx: m.x, cy: m.y, wz });\n            //   console.log(w.x, w.y)\n            w = { x: Math.round(w.x), y: Math.round(w.y) };\n            const tile = tiles.find(tile => tile.position.x === w.x && tile.position.y === w.y && tile.z === wz);\n            if (tile !== undefined) {\n                // console.log(w.x, w.y, wz)\n                cursorWorldPosition = { x: w.x, y: w.y, z: wz };\n                break;\n            }\n        }\n    });\n    let showGrid = true;\n    //   elements.toggleGrid.onclick = () => {\n    //     showGrid = !showGrid\n    //   }\n    CyclicButtonManager(['Grid On', 'Grid Off'], 'Grid On', 'toggleGrid', (value) => {\n        showGrid = value === 'Grid On';\n        console.log(value, showGrid);\n    });\n    requestAnimationFrame(time => {\n        RenderLoop(time, tiles);\n    });\n};\nconst GetLocalStorageItem = (key, defaultValue) => {\n    const value = localStorage.getItem(key);\n    if (value === null) {\n        localStorage.setItem(key, defaultValue);\n        return defaultValue;\n    }\n    else {\n        return value;\n    }\n};\nconst CyclicButtonManager = (values, defaultValue, name, onChangeCallback) => {\n    const element = elements[name]; // also display element\n    const storageKey = name;\n    const Initialise = () => {\n        const value = GetLocalStorageItem(storageKey, defaultValue);\n        element.textContent = value;\n        onChangeCallback(value);\n    };\n    Initialise();\n    const CycleCounter = () => {\n        let value = element.textContent;\n        const index = values.findIndex(other => other === value);\n        const nextIndex = (index + 1) % values.length;\n        value = values[nextIndex];\n        element.textContent = value;\n        localStorage.setItem(storageKey, value);\n        onChangeCallback(value);\n    };\n    element.onclick = () => CycleCounter();\n};\nconst elements = GetElements();\nconst main = async () => {\n    const canvas = elements.canvas;\n    canvas.width = 512;\n    canvas.height = 512;\n    const renderer = Renderer();\n};\nmain();\n\n\n//# sourceURL=webpack:///./src/front_end/main.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/front_end/main.ts"]();
/******/ 	
/******/ })()
;