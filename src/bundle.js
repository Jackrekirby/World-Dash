/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/front_end/dom/cyclicButtonManager.ts":
/*!**************************************************!*\
  !*** ./src/front_end/dom/cyclicButtonManager.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CyclicButtonManager = void 0;\nconst elements_1 = __webpack_require__(/*! ./elements */ \"./src/front_end/dom/elements.ts\");\nconst localStorage_1 = __webpack_require__(/*! ./localStorage */ \"./src/front_end/dom/localStorage.ts\");\n// TODO: add back reset local storage callback\nconst CyclicButtonManager = ({ values, defaultValue, name, ToString = String, // toString is a built in js method\nFromString = (value) => value, OnChangeCallback = () => { } }) => {\n    const element = elements_1.elements[name]; // also display element\n    const storageKey = name;\n    const Initialise = () => {\n        const value = (0, localStorage_1.GetLocalStorageItem)(storageKey, ToString(defaultValue));\n        element.textContent = value;\n        OnChangeCallback(FromString(value));\n    };\n    Initialise();\n    const CycleCounter = () => {\n        let valueStr = element.textContent === null\n            ? ToString(defaultValue)\n            : element.textContent;\n        let value = FromString(valueStr);\n        const index = values.findIndex(other => other === value);\n        const nextIndex = (index + 1) % values.length;\n        value = values[nextIndex];\n        valueStr = ToString(value);\n        element.textContent = valueStr;\n        localStorage.setItem(storageKey, valueStr);\n        OnChangeCallback(value);\n    };\n    element.onclick = () => CycleCounter();\n};\nexports.CyclicButtonManager = CyclicButtonManager;\n\n\n//# sourceURL=webpack:///./src/front_end/dom/cyclicButtonManager.ts?");

/***/ }),

/***/ "./src/front_end/dom/elements.ts":
/*!***************************************!*\
  !*** ./src/front_end/dom/elements.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.elements = void 0;\nconst elementIds = [\n    'canvas',\n    'toggleGrid',\n    'randomiseWorld',\n    'tileScale'\n];\nconst GetElements = () => {\n    const elements = Object.fromEntries(elementIds.map(id => [id, document.getElementById(id)]));\n    const nullElements = Object.keys(elements).filter(id => elements[id] === null);\n    if (nullElements.length > 0) {\n        throw new Error(`Failed to find all elements by id ${nullElements}`);\n    }\n    return elements;\n};\nexports.elements = GetElements();\n\n\n//# sourceURL=webpack:///./src/front_end/dom/elements.ts?");

/***/ }),

/***/ "./src/front_end/dom/localStorage.ts":
/*!*******************************************!*\
  !*** ./src/front_end/dom/localStorage.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GetLocalStorageItem = void 0;\nconst GetLocalStorageItem = (key, defaultValue) => {\n    const value = localStorage.getItem(key);\n    if (value === null) {\n        localStorage.setItem(key, defaultValue);\n        return defaultValue;\n    }\n    else {\n        return value;\n    }\n};\nexports.GetLocalStorageItem = GetLocalStorageItem;\n\n\n//# sourceURL=webpack:///./src/front_end/dom/localStorage.ts?");

/***/ }),

/***/ "./src/front_end/dom/main.ts":
/*!***********************************!*\
  !*** ./src/front_end/dom/main.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InitialiseDom = void 0;\nconst cursor_1 = __webpack_require__(/*! ../game/cursor */ \"./src/front_end/game/cursor.ts\");\nconst main_1 = __webpack_require__(/*! ../game/main */ \"./src/front_end/game/main.ts\");\nconst cyclicButtonManager_1 = __webpack_require__(/*! ./cyclicButtonManager */ \"./src/front_end/dom/cyclicButtonManager.ts\");\nconst elements_1 = __webpack_require__(/*! ./elements */ \"./src/front_end/dom/elements.ts\");\nconst InitialiseDom = (world, renderer, game) => {\n    (0, cyclicButtonManager_1.CyclicButtonManager)({\n        values: ['Grid On', 'Grid Off'],\n        defaultValue: 'Grid On',\n        name: 'toggleGrid',\n        OnChangeCallback: (value) => {\n            const showGrid = value === 'Grid On';\n            game.showGrid = showGrid;\n        }\n    });\n    (0, cyclicButtonManager_1.CyclicButtonManager)({\n        values: [1, 2, 4, 8],\n        defaultValue: 4,\n        name: 'tileScale',\n        OnChangeCallback: (scale) => {\n            renderer.SetScale(scale);\n        },\n        ToString: String,\n        FromString: Number\n    });\n    elements_1.elements.canvas.addEventListener('mousemove', (event) => {\n        const canvasPosition = { x: event.offsetX, y: event.offsetY };\n        const worldPosition = (0, cursor_1.CalculateCursorWorldPosition)(renderer, world, canvasPosition);\n        world.SetCursorWorldPosition(worldPosition);\n    });\n    elements_1.elements.randomiseWorld.onclick = () => {\n        world.GenerateTiles({ landAxialRadius: 6, worldAxialRadius: 12 });\n        game.playerPosition = (0, main_1.RandomisePlayerPosition)(world);\n    };\n};\nexports.InitialiseDom = InitialiseDom;\n\n\n//# sourceURL=webpack:///./src/front_end/dom/main.ts?");

/***/ }),

/***/ "./src/front_end/game/cursor.ts":
/*!**************************************!*\
  !*** ./src/front_end/game/cursor.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CalculateCursorWorldPosition = void 0;\nconst CalculateCursorWorldPosition = (renderer, world, canvasPosition) => {\n    for (let wz = 4; wz >= 0; wz--) {\n        const fw = renderer.CanvasToWorldPosition({\n            canvasPosition,\n            wz\n        }); // floating point world position\n        const w = {\n            x: Math.round(fw.x),\n            y: Math.round(fw.y),\n            z: Math.round(fw.z)\n        };\n        const tile = world.GetTile(w);\n        if (tile !== undefined) {\n            return w;\n        }\n    }\n    return null;\n};\nexports.CalculateCursorWorldPosition = CalculateCursorWorldPosition;\n\n\n//# sourceURL=webpack:///./src/front_end/game/cursor.ts?");

/***/ }),

/***/ "./src/front_end/game/main.ts":
/*!************************************!*\
  !*** ./src/front_end/game/main.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Render = exports.RandomisePlayerPosition = void 0;\nconst types_1 = __webpack_require__(/*! ../renderer/types */ \"./src/front_end/renderer/types.ts\");\nconst types_2 = __webpack_require__(/*! ../world/types */ \"./src/front_end/world/types.ts\");\nconst RandomisePlayerPosition = (world) => {\n    for (let i = 0; i < 100; i++) {\n        const p = {\n            x: Math.floor(Math.random() * 6) - 3,\n            y: Math.floor(Math.random() * 6) - 3\n        };\n        const tile = world.GetSurfaceTile(p);\n        if (tile !== undefined && tile.tileType !== types_2.TileType.water) {\n            return { x: tile.p.x, y: tile.p.y, z: tile.p.z + 1 };\n        }\n    }\n    console.warn('Failed to find valid tile for player to stand on');\n    return { x: 0, y: 0, z: 0 };\n};\nexports.RandomisePlayerPosition = RandomisePlayerPosition;\nconst Render = (time, renderer, world, tiles, game) => {\n    renderer.ClearCanvas();\n    // draw tiles\n    const rTiles = [...tiles];\n    // draw cursor\n    const cursorWorldPosition = world.GetCursorWorldPosition();\n    if (cursorWorldPosition !== null) {\n        const cursorTile = {\n            worldPosition: cursorWorldPosition,\n            tileIndex: { x: 0, y: 0 },\n            tileset: types_1.TileSet.mapIndicators\n        };\n        rTiles.push(cursorTile);\n    }\n    // draw player\n    const playerTile = {\n        worldPosition: game.playerPosition,\n        tileIndex: { x: time % 1000 < 500 ? 0 : 1, y: 0 },\n        tileset: types_1.TileSet.entities\n    };\n    rTiles.push(playerTile);\n    // sort tiles for render (move into renderer)\n    rTiles.sort((a, b) => {\n        const aw = a.worldPosition.x + a.worldPosition.y;\n        const bw = b.worldPosition.x + b.worldPosition.y;\n        if (aw === bw) {\n            // if tiles on same x,y, render from bottom to top\n            return a.worldPosition.z - b.worldPosition.z;\n        }\n        // render from back to front (negative to positive x, y)\n        return aw - bw;\n    });\n    for (const t of rTiles) {\n        renderer.DrawIsometricTile(t);\n    }\n    // draw grid\n    if (game.showGrid) {\n        renderer.DrawIsometricGrid();\n    }\n};\nexports.Render = Render;\n\n\n//# sourceURL=webpack:///./src/front_end/game/main.ts?");

/***/ }),

/***/ "./src/front_end/game/tilesets.ts":
/*!****************************************!*\
  !*** ./src/front_end/game/tilesets.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GenerateRenderTiles = void 0;\nconst types_1 = __webpack_require__(/*! ../renderer/types */ \"./src/front_end/renderer/types.ts\");\nconst types_2 = __webpack_require__(/*! ../world/types */ \"./src/front_end/world/types.ts\");\nconst CreateTileTypeData = ({ tileIndexesList, tileset, tileSelector }) => {\n    const GetRenderTiles = ({ worldPosition, time }) => {\n        return tileIndexesList.map((tileIndexes, index) => {\n            const i = tileSelector(worldPosition, time);\n            return {\n                worldPosition: {\n                    x: worldPosition.x,\n                    y: worldPosition.y,\n                    z: worldPosition.z + index\n                },\n                tileIndex: tileIndexes[i],\n                tileset\n            };\n        });\n    };\n    return {\n        GetRenderTiles\n    };\n};\nconst CreateBasicTileTypeData = ({ tileIndex, tileset = types_1.TileSet.tiles }) => {\n    return CreateTileTypeData({\n        tileIndexesList: [[tileIndex]],\n        tileset,\n        tileSelector: () => 0\n    });\n};\nconst CreateRandomisedTileTypeData = ({ tileIndexes, tileset = types_1.TileSet.tiles }) => {\n    return CreateTileTypeData({\n        tileIndexesList: [tileIndexes],\n        tileset,\n        tileSelector: (worldPosition, time) => {\n            const z = SurfaceNoise({ x: worldPosition.x, y: worldPosition.y });\n            return Math.floor(z * tileIndexes.length);\n        }\n    });\n};\n// TODO Move this somewhere else\nconst CreateRandomNoise2D = () => {\n    const values = [];\n    const n = 13;\n    for (let y = -n; y < n; y++) {\n        for (let x = -n; x < n; x++) {\n            values.push(Math.random());\n        }\n    }\n    return (p) => {\n        return values[p.x + n + (p.y + n) * (2 * n)];\n    };\n};\nconst SurfaceNoise = CreateRandomNoise2D();\nconst tileMap = new Map([\n    [\n        types_2.TileType.dirt,\n        CreateRandomisedTileTypeData({\n            tileIndexes: [\n                { x: 5, y: 2 },\n                { x: 6, y: 2 }\n            ],\n            tileset: types_1.TileSet.tiles\n        })\n    ],\n    [types_2.TileType.grass, CreateBasicTileTypeData({ tileIndex: { x: 1, y: 0 } })],\n    [types_2.TileType.stone, CreateBasicTileTypeData({ tileIndex: { x: 2, y: 0 } })],\n    [types_2.TileType.sand, CreateBasicTileTypeData({ tileIndex: { x: 3, y: 0 } })],\n    [\n        types_2.TileType.water,\n        CreateTileTypeData({\n            tileIndexesList: [\n                [\n                    { x: 5, y: 6 },\n                    { x: 6, y: 6 },\n                    { x: 7, y: 6 }\n                ]\n            ],\n            tileset: types_1.TileSet.tiles,\n            tileSelector: (worldPosition, time) => {\n                const z = SurfaceNoise({ x: worldPosition.x, y: worldPosition.y });\n                const period = 20000;\n                const wrappedTime = (time + z * period) % period;\n                const i = Math.floor(wrappedTime / (period / 3));\n                return i;\n            }\n        })\n    ],\n    [\n        types_2.TileType.plant,\n        CreateRandomisedTileTypeData({\n            tileIndexes: [\n                { x: 4, y: 3 },\n                { x: 5, y: 3 },\n                { x: 6, y: 3 },\n                { x: 4, y: 4 },\n                { x: 5, y: 4 },\n                { x: 6, y: 4 }\n            ],\n            tileset: types_1.TileSet.tiles\n        })\n    ],\n    [types_2.TileType.cactus, CreateBasicTileTypeData({ tileIndex: { x: 8, y: 1 } })],\n    [types_2.TileType.log, CreateBasicTileTypeData({ tileIndex: { x: 8, y: 3 } })],\n    [types_2.TileType.canopy, CreateBasicTileTypeData({ tileIndex: { x: 7, y: 3 } })],\n    [\n        types_2.TileType.dryGrass,\n        CreateRandomisedTileTypeData({\n            tileIndexes: [\n                { x: 3, y: 2 },\n                { x: 4, y: 2 }\n            ],\n            tileset: types_1.TileSet.tiles\n        })\n    ],\n    [\n        types_2.TileType.smallStones,\n        CreateBasicTileTypeData({ tileIndex: { x: 8, y: 0 } })\n    ],\n    [\n        types_2.TileType.largeStones,\n        CreateBasicTileTypeData({ tileIndex: { x: 9, y: 0 } })\n    ],\n    [types_2.TileType.lava, CreateBasicTileTypeData({ tileIndex: { x: 2, y: 3 } })],\n    [\n        types_2.TileType.blueOrchid,\n        CreateTileTypeData({\n            tileIndexesList: [\n                [\n                    { x: 10, y: 6 },\n                    { x: 9, y: 6 }\n                ]\n            ],\n            tileset: types_1.TileSet.tiles,\n            tileSelector: (worldPosition, time) => {\n                // const perlin = NOISE_MANAGER.GetNoise('plants')\n                const z = SurfaceNoise({ x: worldPosition.x, y: worldPosition.y });\n                const period = 19000;\n                const offset = z * period;\n                const [start, end] = [offset, offset + 1000];\n                const wrappedTime = time % period;\n                // console.log({ start, end, worldPosition, time, z })\n                if (start < wrappedTime && wrappedTime < end) {\n                    return 1;\n                }\n                else {\n                    return 0;\n                }\n            }\n        })\n    ],\n    [types_2.TileType.rose, CreateBasicTileTypeData({ tileIndex: { x: 8, y: 6 } })],\n    [\n        types_2.TileType.palmTree,\n        CreateTileTypeData({\n            tileIndexesList: [[{ x: 10, y: 4 }], [{ x: 10, y: 3 }]],\n            tileset: types_1.TileSet.tiles,\n            tileSelector: (worldPosition, time) => 0\n        })\n    ],\n    [\n        types_2.TileType.dirtFrontEdge,\n        CreateRandomisedTileTypeData({\n            tileIndexes: [\n                { x: 0, y: 4 },\n                { x: 1, y: 4 },\n                { x: 2, y: 4 }\n            ],\n            tileset: types_1.TileSet.tiles\n        })\n    ]\n]);\nconst MapGet = (map, key) => {\n    const value = map.get(key);\n    if (value === undefined) {\n        throw Error(`Key ${key} not found in map ${map}`);\n    }\n    return value;\n};\nconst GenerateRenderTiles = ({ worldTiles, time }) => {\n    const rTiles = []; // render tiles\n    for (const wTile of worldTiles) {\n        const tileTypeData = tileMap.get(wTile.tileType);\n        if (tileTypeData === undefined) {\n            throw Error(`Tiletype ${wTile.tileType} not in tilemap`);\n        }\n        const rts = tileTypeData.GetRenderTiles({\n            worldPosition: wTile.p,\n            time\n        });\n        rTiles.push(...rts);\n    }\n    return rTiles;\n};\nexports.GenerateRenderTiles = GenerateRenderTiles;\n\n\n//# sourceURL=webpack:///./src/front_end/game/tilesets.ts?");

/***/ }),

/***/ "./src/front_end/main.ts":
/*!*******************************!*\
  !*** ./src/front_end/main.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst elements_1 = __webpack_require__(/*! ./dom/elements */ \"./src/front_end/dom/elements.ts\");\nconst main_1 = __webpack_require__(/*! ./dom/main */ \"./src/front_end/dom/main.ts\");\nconst main_2 = __webpack_require__(/*! ./game/main */ \"./src/front_end/game/main.ts\");\nconst tilesets_1 = __webpack_require__(/*! ./game/tilesets */ \"./src/front_end/game/tilesets.ts\");\nconst main_3 = __webpack_require__(/*! ./procedural/main */ \"./src/front_end/procedural/main.ts\");\nconst main_4 = __webpack_require__(/*! ./renderer/main */ \"./src/front_end/renderer/main.ts\");\nconst main_5 = __webpack_require__(/*! ./world/main */ \"./src/front_end/world/main.ts\");\nconsole.log('Isometric');\nconst main = async () => {\n    const canvas = elements_1.elements.canvas;\n    canvas.width = 512;\n    canvas.height = 512;\n    // RunShadeMap()\n    // GenerateProceduralConnectedTextures2({\n    //   innerMinAlpha: 1.0,\n    //   innerMaxAlpha: 1.0,\n    //   innerPixelChance: 1.0,\n    //   outerMinAlpha: 1.0,\n    //   outerMaxAlpha: 1.0,\n    //   outerPixelChance: 1.0\n    // })\n    (0, main_3.GenerateProceduralConnectedTextures3)();\n    return;\n    const world = (0, main_5.CreateWorld)();\n    world.GenerateTiles({ landAxialRadius: 6, worldAxialRadius: 12 });\n    const renderer = await (0, main_4.CreateRenderer)();\n    const game = {\n        showGrid: false,\n        playerPosition: (0, main_2.RandomisePlayerPosition)(world)\n    };\n    (0, main_1.InitialiseDom)(world, renderer, game);\n    const RenderLoop = () => {\n        requestAnimationFrame((time) => {\n            const rTiles = (0, tilesets_1.GenerateRenderTiles)({\n                worldTiles: world.GetTiles(),\n                time\n            });\n            (0, main_2.Render)(time, renderer, world, rTiles, game);\n            RenderLoop();\n        });\n    };\n    RenderLoop();\n};\nmain();\n\n\n//# sourceURL=webpack:///./src/front_end/main.ts?");

/***/ }),

/***/ "./src/front_end/miscellaneous/perlin_noise.ts":
/*!*****************************************************!*\
  !*** ./src/front_end/miscellaneous/perlin_noise.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NOISE_MANAGER = exports.NoiseManager = exports.CreatePerlinNoise = void 0;\nconst CreatePerlinNoise = () => {\n    const _p = [];\n    const _permutation = [];\n    const initialise = () => {\n        // Initialize the permutation table\n        for (let i = 0; i < 256; i++) {\n            _p[i] = Math.floor(Math.random() * 256);\n        }\n        // Duplicate the permutation table\n        for (let i = 0; i < 256; i++) {\n            _permutation[i] = _p[i % 256];\n        }\n    };\n    // Fade function to smooth the interpolation\n    const fade = (t) => {\n        return t * t * t * (t * (t * 6 - 15) + 10);\n    };\n    // Dot product of the gradient and the distance vector\n    const grad = (hash, x, y) => {\n        const h = hash & 15; // Determine which gradient to use\n        const u = h < 8 ? x : y;\n        const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;\n        return (h & 1 ? -u : u) + (h & 2 ? -v : v);\n    };\n    const lerp = (a, b, t) => {\n        return a + t * (b - a);\n    };\n    const noise = (x, y) => {\n        const X = Math.floor(x) & 255; // Calculate grid cell coordinates\n        const Y = Math.floor(y) & 255;\n        x -= Math.floor(x); // Relative position in grid cell\n        y -= Math.floor(y);\n        const u = fade(x); // Fade the x coordinate\n        const v = fade(y); // Fade the y coordinate\n        // Hash coordinates of the 4 corners\n        const a = _permutation[X] + Y;\n        const aa = _permutation[a];\n        const ab = _permutation[a + 1];\n        const b = _permutation[X + 1] + Y;\n        const ba = _permutation[b];\n        const bb = _permutation[b + 1];\n        // Interpolate between gradients at the four corners\n        const x1 = lerp(grad(aa, x, y), grad(ba, x - 1, y), u);\n        const x2 = lerp(grad(ab, x, y - 1), grad(bb, x - 1, y - 1), u);\n        return lerp(x1, x2, v); // Final interpolation\n    };\n    const layeredNoise = ({ x, y, octaves = 1 }) => {\n        let total = 0;\n        let frequency = 1;\n        let amplitude = 1;\n        for (let i = 0; i < octaves; i++) {\n            total += noise(x * frequency, y * frequency) * amplitude;\n            frequency *= 2;\n            amplitude *= 0.5;\n        }\n        return total;\n    };\n    initialise();\n    return {\n        noise: layeredNoise\n    };\n};\nexports.CreatePerlinNoise = CreatePerlinNoise;\nconst NoiseManager = () => {\n    const noiseCollection = new Map([]);\n    const GetNoise = (key) => {\n        if (!noiseCollection.has(key)) {\n            noiseCollection.set(key, (0, exports.CreatePerlinNoise)());\n        }\n        return noiseCollection.get(key);\n    };\n    return {\n        GetNoise\n    };\n};\nexports.NoiseManager = NoiseManager;\n// singleton...\nexports.NOISE_MANAGER = (0, exports.NoiseManager)();\n\n\n//# sourceURL=webpack:///./src/front_end/miscellaneous/perlin_noise.ts?");

/***/ }),

/***/ "./src/front_end/procedural/main.ts":
/*!******************************************!*\
  !*** ./src/front_end/procedural/main.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RenderPixelMap = exports.GenerateProceduralConnectedTextures3 = exports.ConnectedTextureManager = exports.GenerateProceduralConnectedTextures2 = exports.GenerateProceduralConnectedTextures = exports.GenerateProceduralGrassTextures = void 0;\nconst elements_1 = __webpack_require__(/*! ../dom/elements */ \"./src/front_end/dom/elements.ts\");\nconst main_1 = __webpack_require__(/*! ../renderer/main */ \"./src/front_end/renderer/main.ts\");\nconst shademaps_1 = __webpack_require__(/*! ./shademaps */ \"./src/front_end/procedural/shademaps.ts\");\nconst WeightedRandom = (r, weights) => {\n    let t = 0;\n    for (let i = 0; i < weights.length; i++) {\n        t += weights[i];\n        if (r < t) {\n            return i;\n        }\n    }\n    return weights.length;\n};\nconst GenerateProceduralGrassTextures = () => {\n    const canvas = elements_1.elements.canvas;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n        throw new Error('Failed to get 2D context');\n    }\n    const [width, height] = [canvas.width, canvas.height];\n    const numOfTiles = 2;\n    const tilesize = 16;\n    const unscaledHeight = tilesize * numOfTiles;\n    const scale = 512 / unscaledHeight;\n    const [w, h] = [width / scale, height / scale];\n    const ClearCanvas = () => {\n        ctx.clearRect(0, 0, width, height);\n    };\n    ClearCanvas();\n    ctx.fillStyle = 'hsla(89, 53%, 44%, 1)';\n    ctx.fillRect(0, 0, width, height);\n    const world = Array(w * h).fill(0);\n    const setPixelIfNoNeighbours = (ps, i) => {\n        const neighbours = [\n            { x: 0, y: 0 },\n            { x: 1, y: 0 },\n            { x: -1, y: 0 },\n            { x: 0, y: 1 },\n            { x: 0, y: -1 }\n        ];\n        for (const p of ps) {\n            for (const n of neighbours) {\n                const other = world[p.x + n.x + (p.y + n.y) * w];\n                if (other === i) {\n                    return;\n                }\n            }\n        }\n        const clrs = ['', 'hsla(130, 37%, 35%, 1)', 'hsla(72, 65%, 54%, 1)'];\n        ctx.fillStyle = clrs[i];\n        for (const p of ps) {\n            world[p.x + p.y * w] = i;\n            ctx.fillRect(p.x * scale, p.y * scale, 1 * scale, 1 * scale);\n        }\n    };\n    for (let i = 0; i < w * h * 0.3; i++) {\n        // i = number of grass strands\n        const p = {\n            x: Math.floor(Math.random() * w),\n            y: Math.floor(Math.random() * h)\n        };\n        // if (Math.random() < 0.5) {\n        //   ctx.fillStyle = 'hsla(130, 37%, 35%, 1)'\n        // } else {\n        //   ctx.fillStyle = 'hsla(72, 65%, 54%, 1)'\n        // }\n        const r = Math.random();\n        const ri = WeightedRandom(r, [0.5, 0.2, 0.2, 0.1]);\n        let ps = [];\n        if (ri == 0) {\n            ps = [p, { x: p.x, y: p.y - 1 }];\n        }\n        else if (ri == 1) {\n            ps = [p, { x: p.x, y: p.y - 1 }, { x: p.x, y: p.y - 2 }];\n        }\n        else if (ri == 2) {\n            ps = [p, { x: p.x, y: p.y - 1 }, { x: p.x + 1, y: p.y }];\n        }\n        else if (ri == 3) {\n            ps = [p];\n        }\n        setPixelIfNoNeighbours(ps, Math.round(Math.random() + 1));\n    }\n    //   let hueIndex = 0\n    //   for (let xi = 0; xi <= numOfTiles * 2; xi += 1) {\n    //     let dy: number\n    //     if (xi % 2 === 1) {\n    //       dy = 4\n    //     } else {\n    //       dy = 0\n    //     }\n    //     const x = (xi * tilesize) / 2\n    //     for (let y = 0; y <= unscaledHeight; y++) {\n    //       const ly = y % 7\n    //       const ai = Math.abs(ly - 3)\n    //       const w = tilesize - ai * 4\n    //       const h = 1\n    //       const dx = (tilesize - w) / 2\n    //       //   console.log({ x, y, w, h })\n    //       const hue = (Math.floor(hueIndex) * 60) % 360\n    //       ctx.fillStyle = `hsla(${hue}, 100%, 50%, 0.5)`\n    //       ctx.fillRect((x + dx) * scale, (y + dy) * scale, w * scale, h * scale)\n    //       hueIndex += 1 / 7\n    //       if (Math.floor(hueIndex) == 1) {\n    //         return\n    //       }\n    //     }\n    //   }\n    const weights = [\n        [6, 2],\n        [4, 4],\n        [2, 6],\n        [0, 8],\n        [2, 6],\n        [4, 4],\n        [6, 2],\n        [8, 0]\n    ];\n    for (let y = 0; y < height / scale; y++) {\n        const yi = y % 8;\n        const [w1, w2] = weights[yi];\n        for (let x = 0; x < width / scale; x++) {\n            const xi = x % (w1 + w2);\n            const xn = Math.floor(x / (w1 + w2));\n            let clr;\n            if (xn % 2 == 0) {\n                clr = xi < w1 ? `hsla(0, 0%, 0%, 0.05)` : `hsla(0, 0%, 100%, 0.05)`;\n            }\n            else {\n                clr = xi < w2 ? `hsla(0, 0%, 100%, 0.05)` : `hsla(0, 0%, 0%, 0.05)`;\n            }\n            ctx.fillStyle = clr;\n            ctx.fillRect(x * scale, y * scale, 1 * scale, 1 * scale);\n        }\n    }\n};\nexports.GenerateProceduralGrassTextures = GenerateProceduralGrassTextures;\nconst GenerateProceduralConnectedTextures = async () => {\n    const canvas = elements_1.elements.canvas;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n        throw new Error('Failed to get 2D context');\n    }\n    const [w, h] = [16, 17];\n    const scale = 1;\n    canvas.width = w * scale;\n    canvas.height = h * scale;\n    ctx.imageSmoothingEnabled = false;\n    const ClearCanvas = () => {\n        ctx.clearRect(0, 0, w * scale, h * scale);\n    };\n    ClearCanvas();\n    const images = {\n        grass: await (0, main_1.LoadImage)('assets/grass_block.png'),\n        dirt: await (0, main_1.LoadImage)('assets/dirt_block.png'),\n        fade: await (0, main_1.LoadImage)('assets/fade_map_py.png')\n    };\n    // ctx.drawImage(images.grass, 0, 0, w, h, 0, 0, w * scale, h * scale)\n    const help = () => {\n        const canvas = document.createElement('canvas');\n        canvas.width = w;\n        canvas.height = h;\n        const ctx2 = canvas.getContext('2d');\n        if (!ctx2) {\n            throw new Error('Failed to get 2D context');\n        }\n        ctx2.drawImage(images.fade, 0, 0);\n        const clrs = [];\n        const rs = [];\n        const data = ctx2.getImageData(0, 0, 16, 17);\n        for (let i = 0; i < data.data.length; i += 4) {\n            const r = data.data[i];\n            let j = clrs.findIndex(c => c === r);\n            if (j === -1) {\n                clrs.push(r);\n                j = clrs.findIndex(c => c === r);\n            }\n            rs.push(j);\n        }\n        // console.log(rs)\n        let s = '';\n        for (let y = 0; y < h; y++) {\n            s += rs.slice(y * w, (y + 1) * w).join(' ');\n            s += '\\n';\n        }\n        console.log(s);\n        for (let y = 0; y < h; y++) {\n            for (let x = 0; x < w; x++) {\n                const v = rs[x + y * w];\n                if (v === 0) {\n                    continue;\n                }\n                const a2 = [0.2, 0.6, 0.8];\n                ctx.globalAlpha = a2[v];\n                const w2 = [0.8, 0.6, 0.4];\n                if (Math.random() > w2[v]) {\n                    continue;\n                }\n                ctx.drawImage(images.dirt, x, y, 1, 1, x * scale, y * scale, 1 * scale, 1 * scale);\n            }\n        }\n    };\n    help();\n    const link = document.createElement('a'); // Create an <a> element\n    link.download = 'canvas-image.png'; // Set the download attribute\n    link.href = canvas.toDataURL(); // Convert canvas to data URL\n    link.click(); // Simulate a click to trigger the download\n};\nexports.GenerateProceduralConnectedTextures = GenerateProceduralConnectedTextures;\nconst BooleansToNumber = (booleans) => {\n    return booleans.reduce((acc, val, index) => {\n        // Shift the accumulator left and add the current value as a bit\n        return (acc << 1) | (val ? 1 : 0);\n    }, 0);\n};\nconst GenerateBooleanCombinations = (n) => {\n    // The result array to hold all combinations\n    const result = [];\n    // Total number of combinations is 2^n\n    const totalCombinations = 1 << n;\n    for (let i = 0; i < totalCombinations; i++) {\n        const combination = [];\n        for (let j = 0; j < n; j++) {\n            // Use bitwise AND to determine if the j-th bit in i is set\n            combination.push((i & (1 << j)) !== 0);\n        }\n        result.push(combination);\n    }\n    return result;\n};\nconst ScaleCanvas = (canvas, scaleFactor) => {\n    const [w, h] = [canvas.width, canvas.height];\n    const otherCanvas = document.createElement('canvas');\n    const otherCtx = otherCanvas.getContext('2d');\n    if (!otherCtx) {\n        throw new Error('Offscreen canvas context could not be retrieved.');\n    }\n    otherCanvas.width = w * scaleFactor;\n    otherCanvas.height = h * scaleFactor;\n    otherCtx.imageSmoothingEnabled = false;\n    otherCtx.drawImage(canvas, 0, 0, w * scaleFactor, h * scaleFactor);\n    return otherCanvas;\n};\nconst SetCanvasContent = (targetCanvas, sourceCanvas) => {\n    const targetContext = targetCanvas.getContext('2d');\n    const sourceContext = sourceCanvas.getContext('2d');\n    if (!targetContext || !sourceContext) {\n        throw new Error('Unable to retrieve the 2D rendering context for one of the canvases.');\n    }\n    targetContext.imageSmoothingEnabled = false;\n    sourceContext.imageSmoothingEnabled = false;\n    // Match the target canvas size to the source canvas size\n    targetCanvas.width = sourceCanvas.width;\n    targetCanvas.height = sourceCanvas.height;\n    // Copy the content from the source canvas to the target canvas\n    targetContext.drawImage(sourceCanvas, 0, 0);\n};\nconst GenerateProceduralConnectedTextures2 = async ({ innerMinAlpha = 0.3, innerMaxAlpha = 0.8, innerPixelChance = 0.5, outerMinAlpha = 0.1, outerMaxAlpha = 0.5, outerPixelChance = 0.25 } = {}) => {\n    const scale = 4;\n    const [w, h] = [16, 17];\n    const a = w * h;\n    const canvas = document.createElement('canvas');\n    canvas.width = w * scale;\n    canvas.height = h * scale;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n        throw new Error('Failed to get 2D context');\n    }\n    ctx.imageSmoothingEnabled = false;\n    const ClearCanvas = () => {\n        ctx.clearRect(0, 0, w * scale, h * scale);\n    };\n    ClearCanvas();\n    // const image = await LoadImage('assets/dirt_block.png')\n    // const mask2 = await LoadImage('assets/mask.png')\n    // ctx.drawImage(image, 0, 0, w * scale, h * scale)\n    // ctx.globalCompositeOperation = 'destination-in'\n    // ctx.drawImage(mask2, 0, 0, w * scale, h * scale)\n    // ctx.globalCompositeOperation = 'source-over'\n    const pixelMapManager = (0, shademaps_1.PixelMapManager)();\n    const pixelPositions = pixelMapManager.GetPixelPositions();\n    const combos = GenerateBooleanCombinations(4); // 4^2 = 16\n    for (let i = 0; i < 16; i++) {\n        const combo = combos[i];\n        const CreateMask = (offset) => {\n            const xs = [];\n            const ys = [];\n            if (combo[0]) {\n                xs.push(1 + offset);\n            }\n            if (combo[1]) {\n                xs.push(8 - offset);\n            }\n            if (combo[2]) {\n                ys.push(1 + offset);\n            }\n            if (combo[3]) {\n                ys.push(8 - offset);\n            }\n            const mask = pixelPositions.map(p => {\n                return p.z === 10 && (xs.includes(p.x) || ys.includes(p.y));\n            });\n            return mask;\n        };\n        const outerMask = CreateMask(0);\n        const innerMask = CreateMask(1);\n        const p = { x: i % 4, y: Math.floor(i / 4) };\n        for (let j = 0; j < a; j++) {\n            if (outerMask[j] && Math.random() < outerPixelChance) {\n                const alpha = outerMinAlpha + Math.random() * (outerMaxAlpha - outerMinAlpha);\n                ctx.fillStyle = `hsla(0, 100%, 100%, ${alpha})`;\n                ctx.fillRect(p.x * w + (j % w), p.y * h + Math.floor(j / w), 1, 1);\n            }\n            if (innerMask[j] && Math.random() < innerPixelChance) {\n                const alpha = innerMinAlpha + Math.random() * (innerMaxAlpha - innerMinAlpha);\n                ctx.fillStyle = `hsla(0, 100%, 100%, ${alpha})`;\n                ctx.fillRect(p.x * w + (j % w), p.y * h + Math.floor(j / w), 1, 1);\n            }\n        }\n    }\n    SetCanvasContent(elements_1.elements.canvas, ScaleCanvas(canvas, 10));\n    elements_1.elements.randomiseWorld.onclick = () => {\n        const link = document.createElement('a');\n        link.download = 'edge_masks.png';\n        link.href = canvas.toDataURL();\n        link.click();\n    };\n};\nexports.GenerateProceduralConnectedTextures2 = GenerateProceduralConnectedTextures2;\nconst IndexToPos2D = (i, w) => {\n    return { x: i % w, y: Math.floor(i / w) };\n};\nconst ConnectedTextureManager = async () => {\n    const mask = await (0, main_1.LoadImage)('assets/edge_masks.png');\n    const [w, h] = [16, 17];\n    const cache = new Map();\n    const GetConnectedTexture = ({ name, image, px, nx, py, ny }) => {\n        const key = `${name}_${px ? 'px' : ''}${py ? 'py' : ''}${nx ? 'nx' : ''}${ny ? 'ny' : ''}`;\n        const cachedCanvas = cache.get(key);\n        if (cachedCanvas !== undefined) {\n            return cachedCanvas;\n        }\n        const canvas = document.createElement('canvas');\n        canvas.width = w;\n        canvas.height = h;\n        const ctx = canvas.getContext('2d');\n        if (!ctx) {\n            throw new Error('Failed to get 2D context');\n        }\n        ctx.imageSmoothingEnabled = false;\n        ctx.drawImage(image, 0, 0, w, h);\n        // px nx py ny\n        const comboId = BooleansToNumber([px, nx, py, ny]);\n        const c = IndexToPos2D(comboId, 4);\n        ctx.globalCompositeOperation = 'destination-in';\n        ctx.drawImage(mask, c.x * w, c.y * h, w, h, 0, 0, w, h);\n        ctx.globalCompositeOperation = 'source-over';\n        cache.set(key, canvas);\n        return canvas;\n    };\n    return { GetConnectedTexture };\n};\nexports.ConnectedTextureManager = ConnectedTextureManager;\nconst GenerateProceduralConnectedTextures3 = async () => {\n    const m = await (0, exports.ConnectedTextureManager)();\n    const block = await (0, main_1.LoadImage)('assets/grass_block.png');\n    const canvas = m.GetConnectedTexture({\n        name: 'grass',\n        image: block,\n        px: true,\n        py: true,\n        nx: false,\n        ny: false\n    });\n    SetCanvasContent(elements_1.elements.canvas, ScaleCanvas(canvas, 20));\n    elements_1.elements.randomiseWorld.onclick = () => {\n        const link = document.createElement('a');\n        link.download = 'edge_masks.png';\n        link.href = canvas.toDataURL();\n        link.click();\n    };\n};\nexports.GenerateProceduralConnectedTextures3 = GenerateProceduralConnectedTextures3;\nconst RenderPixelMap = () => {\n    const canvas = elements_1.elements.canvas;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n        throw new Error('Failed to get 2D context');\n    }\n    const [w, h] = [16, 17];\n    const scale = 20;\n    canvas.width = w * scale * 2;\n    canvas.height = h * scale * 2;\n    ctx.imageSmoothingEnabled = false;\n    const ClearCanvas = () => {\n        ctx.clearRect(0, 0, w * scale * 2, h * scale * 2);\n    };\n    ClearCanvas();\n    const DrawMap = (offset, pixelMap, hue, alpha = 1) => {\n        const maxValue = Math.max(...pixelMap.flat()) + 2;\n        for (let y = 0; y < h; y++) {\n            for (let x = 0; x < w; x++) {\n                const k = (pixelMap[x + y * w] / maxValue) * 100;\n                ctx.fillStyle = `hsla(${hue}, 100%, ${k}%, ${alpha})`;\n                ctx.fillRect(offset.x + x * scale, offset.y + y * scale, scale, scale);\n            }\n        }\n        ctx.fillStyle = 'hsla(0, 0%, 0, 0)';\n    };\n    const pixelMapManager = (0, shademaps_1.PixelMapManager)();\n    const pixelPositions = pixelMapManager.GetPixelPositions();\n    DrawMap({ x: w * scale, y: h * scale }, pixelPositions.map(p => p.z), 0);\n    DrawMap({ x: w * scale, y: 0 }, pixelPositions.map(p => p.x), 200);\n    DrawMap({ x: 0, y: h * scale }, pixelPositions.map(p => p.y), 100);\n    DrawMap({ x: 0, y: 0 }, pixelPositions.map(p => {\n        if (p.z === 10 && ([1, 8].includes(p.x) || [1, 8].includes(p.y))) {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }), 300);\n};\nexports.RenderPixelMap = RenderPixelMap;\n\n\n//# sourceURL=webpack:///./src/front_end/procedural/main.ts?");

/***/ }),

/***/ "./src/front_end/procedural/shademaps.ts":
/*!***********************************************!*\
  !*** ./src/front_end/procedural/shademaps.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PixelMapManager = exports.RunShadeMap = void 0;\nconst RunShadeMap = () => {\n    ShadeMap();\n};\nexports.RunShadeMap = RunShadeMap;\nconst ShadeMap = () => {\n    const shademap = [\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    ];\n    if (shademap.length !== 17) {\n        throw new Error('Shademap must be 17 in height');\n    }\n    for (const row of shademap) {\n        if (row.length !== 16) {\n            throw new Error('Shademap must be 16 in width');\n        }\n    }\n};\nconst PixelMapManager = () => {\n    const [w, h] = [16, 17];\n    const FormatPixelMap = (map) => {\n        if (map.length !== h) {\n            throw new Error('map must be 17 in height');\n        }\n        for (const row of map) {\n            if (row.length !== w) {\n                throw new Error('map must be 16 in width');\n            }\n        }\n        return map.flat();\n    };\n    const pixelMapZ = FormatPixelMap((() => {\n        const a = 10;\n        return [\n            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, a, a, a, a, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, a, a, a, a, a, a, a, a, 0, 0, 0, 0],\n            [0, 0, a, a, a, a, a, a, a, a, a, a, a, a, 0, 0],\n            [a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a],\n            [9, 9, a, a, a, a, a, a, a, a, a, a, a, a, 9, 9],\n            [8, 8, 9, 9, a, a, a, a, a, a, a, a, 9, 9, 8, 8],\n            [7, 7, 8, 8, 9, 9, a, a, a, a, 9, 9, 8, 8, 7, 7],\n            [6, 6, 7, 7, 8, 8, 9, 9, 9, 9, 8, 8, 7, 7, 6, 6],\n            [5, 5, 6, 6, 7, 7, 8, 8, 8, 8, 7, 7, 6, 6, 5, 5],\n            [4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 6, 6, 5, 5, 4, 4],\n            [3, 3, 4, 4, 5, 5, 6, 6, 6, 6, 5, 5, 4, 4, 3, 3],\n            [2, 2, 3, 3, 4, 4, 5, 5, 5, 5, 4, 4, 3, 3, 2, 2],\n            [1, 1, 2, 2, 3, 3, 4, 4, 4, 4, 3, 3, 2, 2, 1, 1],\n            [0, 0, 1, 1, 2, 2, 3, 3, 3, 3, 2, 2, 1, 1, 0, 0],\n            [0, 0, 0, 0, 1, 1, 2, 2, 2, 2, 1, 1, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0]\n        ];\n    })());\n    const pixelMapXY = [\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 0, 0, 0, 0],\n        [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 0, 0],\n        [1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8],\n        [1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 8, 8],\n        [1, 2, 3, 4, 5, 5, 6, 6, 7, 7, 8, 8, 8, 8, 8, 8],\n        [1, 2, 3, 4, 5, 6, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8],\n        [1, 2, 3, 4, 5, 6, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n        [1, 2, 3, 4, 5, 6, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n        [1, 2, 3, 4, 5, 6, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n        [1, 2, 3, 4, 5, 6, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n        [1, 2, 3, 4, 5, 6, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n        [1, 2, 3, 4, 5, 6, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n        [0, 0, 3, 4, 5, 6, 7, 8, 8, 8, 8, 8, 8, 8, 0, 0],\n        [0, 0, 0, 0, 5, 6, 7, 8, 8, 8, 8, 8, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 7, 8, 8, 8, 0, 0, 0, 0, 0, 0]\n    ];\n    const pixelMapX = FormatPixelMap(pixelMapXY);\n    // Y map is a reflection of X along the vertical axis\n    const pixelMapY = FormatPixelMap(pixelMapXY.map(row => row.slice().reverse()));\n    const GetMatchingPositions = ({ x = [], y = [], z = [] }) => {\n        // find positions that contain indexes along each axis\n        const n = w * h;\n        const matchingPixels = Array(n).fill(true);\n        const AddMatchingPixels = (indices, pixelMap) => {\n            if (indices.length === 0) {\n                return;\n            }\n            for (let i = 0; i < n; i++) {\n                const w = pixelMap[i];\n                if (!indices.includes(w)) {\n                    matchingPixels[i] = false;\n                }\n            }\n        };\n        AddMatchingPixels(x, pixelMapX);\n        AddMatchingPixels(y, pixelMapY);\n        AddMatchingPixels(z, pixelMapZ);\n        const matchingPositions = [];\n        for (let i = 0; i < n; i++) {\n            if (matchingPixels[i]) {\n                matchingPositions.push({ x: i % w, y: Math.floor(i / w) });\n            }\n        }\n        return matchingPositions;\n    };\n    const GetPixelPositions = () => {\n        const n = w * h;\n        const p = [];\n        for (let i = 0; i < n; i++) {\n            p.push({ x: pixelMapX[i], y: pixelMapY[i], z: pixelMapZ[i] });\n        }\n        return p;\n    };\n    const GetPixelMapX = () => {\n        return pixelMapX;\n    };\n    const GetPixelMapY = () => {\n        return pixelMapY;\n    };\n    const GetPixelMapZ = () => {\n        return pixelMapZ;\n    };\n    return {\n        // GetMatchingPositions,\n        GetPixelPositions\n        // GetPixelMapX,\n        // GetPixelMapY,\n        // GetPixelMapZ\n    };\n};\nexports.PixelMapManager = PixelMapManager;\n\n\n//# sourceURL=webpack:///./src/front_end/procedural/shademaps.ts?");

/***/ }),

/***/ "./src/front_end/renderer/main.ts":
/*!****************************************!*\
  !*** ./src/front_end/renderer/main.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CreateRenderer = exports.LoadImage = void 0;\nconst elements_1 = __webpack_require__(/*! ../dom/elements */ \"./src/front_end/dom/elements.ts\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./src/front_end/renderer/types.ts\");\nconst LoadImage = async (src) => {\n    const image = new Image();\n    image.src = src;\n    return new Promise((resolve, reject) => {\n        image.onload = () => resolve(image);\n        image.onerror = err => reject(new Error(`Failed to load image at ${src}`));\n    });\n};\nexports.LoadImage = LoadImage;\nconst CreateRenderer = async () => {\n    const canvas = elements_1.elements.canvas;\n    // Initialise\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n        throw new Error('Failed to get 2D context');\n    }\n    const [width, height] = [canvas.width, canvas.height];\n    ctx.imageSmoothingEnabled = false;\n    const SetScale = (scale) => {\n        _scale = scale;\n        _dts = sts * _scale;\n    };\n    let _scale = 4;\n    const sts = 16; // source tile size\n    let _dts = sts * _scale; // destination tile size\n    const heightOverflow = 1; // pixel\n    const tileSets = new Map([\n        [\n            types_1.TileSet.tiles,\n            await (0, exports.LoadImage)('assets/Isometric_MedievalFantasy_Tiles.png')\n        ],\n        [\n            types_1.TileSet.entities,\n            await (0, exports.LoadImage)('assets/IsometricTRPGAssetPack_OutlinedEntities.png')\n        ],\n        [\n            types_1.TileSet.mapIndicators,\n            await (0, exports.LoadImage)('assets/IsometricTRPGAssetPack_MapIndicators2.png')\n        ]\n    ]);\n    // Member Functions\n    const DrawLine = (x0, y0, x1, y1) => {\n        ctx.beginPath();\n        ctx.moveTo(x0, y0);\n        ctx.lineTo(x1, y1);\n        ctx.stroke();\n    };\n    const DrawIsometricGrid = () => {\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = 'hsla(0, 0%, 50%, 0.5)';\n        for (let x = 0; x < width; x += _dts) {\n            DrawLine(x, 0, x, height);\n        }\n        for (let y = 0; y < height; y += _dts) {\n            DrawLine(0, y, width, y);\n        }\n        ctx.strokeStyle = 'hsl(0, 0%, 100%, 0.5)';\n        for (let x = _dts / 2; x < width; x += _dts) {\n            DrawLine(x, 0, x, height);\n        }\n        for (let y = _dts / 2; y < height; y += _dts) {\n            DrawLine(0, y, width, y);\n        }\n        for (let y = -_dts; y < height; y += _dts) {\n            for (let x = -_dts; x < width; x += _dts) {\n                ctx.strokeStyle = 'hsla(200, 100%, 80%, 0.5)';\n                DrawLine(x, y, x + 2 * _dts, y + _dts);\n                ctx.strokeStyle = 'hsla(100, 100%, 80%, 0.5)';\n                DrawLine(x, y + _dts, x + 2 * _dts, y);\n            }\n        }\n    };\n    const WorldToCanvasPosition = ({ x, y, z }) => {\n        const p0 = {\n            // destination x & y origin (centre)\n            x: (width - _dts) / 2,\n            y: (height - _dts) / 2 - heightOverflow * _scale\n        };\n        const p = {\n            x: p0.x - (x * _dts) / 2 + (y * _dts) / 2,\n            y: p0.y + (x * _dts) / 4 + (y * _dts) / 4 - (z * _dts) / 2\n        };\n        return p;\n    };\n    const DrawIsometricTile = (tile) => {\n        //  /  \\\n        // x    y\n        // w = world x, y & z\n        // ti, tj = tile index in x & y\n        const [sw, sh] = [sts, sts + heightOverflow]; // source width & height (+1 = tile overflow)\n        const [sx, sy] = [tile.tileIndex.x * sw, tile.tileIndex.y * sh]; // source x & y\n        const [dw, dh] = [sw * _scale, sh * _scale]; // destination width & height\n        const [dx0, dy0] = [\n            // destination x & y origin (centre)\n            (width - _dts) / 2,\n            (height - _dts) / 2 - heightOverflow * _scale\n        ];\n        const [dx, dy] = [\n            // destination x & y\n            dx0 -\n                (tile.worldPosition.x * _dts) / 2 +\n                (tile.worldPosition.y * _dts) / 2,\n            dy0 +\n                (tile.worldPosition.x * _dts) / 4 +\n                (tile.worldPosition.y * _dts) / 4 -\n                (tile.worldPosition.z * _dts) / 2\n        ];\n        const d = WorldToCanvasPosition(tile.worldPosition);\n        const image = tileSets.get(tile.tileset);\n        ctx.drawImage(image, sx, sy, sw, sh, d.x, d.y, dw, dh);\n    };\n    const CanvasToWorldPosition = ({ canvasPosition, wz }) => {\n        // EQ.1\n        // _x =  p0.x - (x * dts) / 2 + (y * dts) / 2,\n        // 2/dts * (_x - p0.x)  = - x + y\n        // EQ.2\n        // _y = p0.y + (x * dts) / 4 + (y * dts) / 4 - (z * dts) / 2\n        // 4/dts * (_y - p0.y) + 2*z = x + y\n        // 2*y = EQ.1 + EQ.2\n        // 2*y = 2/dts * (_x - p0.x) + 4/dts * (_y - p0.y) + 2*z\n        // y =  1/dts * (_x - p0.x) + 2/dts * (_y - p0.y) + z\n        // y = 1/dts * (_x - p0.x + 2 * (_y - p0.y)) + z\n        // 2*x = - EQ.1 + EQ.2\n        // 2*x = - 2/dts * (_x - p0.x) + 4/dts * (_y - p0.y) + 2*z\n        // x = - 1/dts * (_x - p0.x) + 2/dts * (_y - p0.y) + z\n        // x = 1/dts * (p0.x - _x + 2 * (_y - p0.y)) + z\n        const cx = canvasPosition.x - _dts / 2;\n        const cy = canvasPosition.y - _dts / 2;\n        const p0 = {\n            // destination x & y origin (centre)\n            x: (width - _dts) / 2,\n            y: (height - _dts) / 2 - heightOverflow * _scale\n        };\n        const p = {\n            x: (1 / _dts) * (p0.x - cx + 2 * (cy - p0.y)) + wz + 0.5,\n            y: (1 / _dts) * (cx - p0.x + 2 * (cy - p0.y)) + wz + 0.5,\n            z: wz\n        };\n        return p;\n    };\n    const ClearCanvas = () => {\n        ctx.clearRect(0, 0, width, height);\n    };\n    return {\n        CanvasToWorldPosition,\n        ClearCanvas,\n        DrawIsometricTile,\n        DrawIsometricGrid,\n        SetScale\n    };\n};\nexports.CreateRenderer = CreateRenderer;\n\n\n//# sourceURL=webpack:///./src/front_end/renderer/main.ts?");

/***/ }),

/***/ "./src/front_end/renderer/types.ts":
/*!*****************************************!*\
  !*** ./src/front_end/renderer/types.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TileSet = void 0;\nvar TileSet;\n(function (TileSet) {\n    TileSet[\"tiles\"] = \"tiles\";\n    TileSet[\"entities\"] = \"entities\";\n    TileSet[\"mapIndicators\"] = \"mapIndicators\";\n})(TileSet || (exports.TileSet = TileSet = {}));\n\n\n//# sourceURL=webpack:///./src/front_end/renderer/types.ts?");

/***/ }),

/***/ "./src/front_end/world/main.ts":
/*!*************************************!*\
  !*** ./src/front_end/world/main.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CreateWorld = void 0;\nconst perlin_noise_1 = __webpack_require__(/*! ../miscellaneous/perlin_noise */ \"./src/front_end/miscellaneous/perlin_noise.ts\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./src/front_end/world/types.ts\");\nconst CreateWorld = () => {\n    let _cursorWorldPosition = null;\n    let _tiles = [];\n    const SetCursorWorldPosition = (cursorWorldPosition) => {\n        _cursorWorldPosition = cursorWorldPosition;\n    };\n    const GetCursorWorldPosition = () => {\n        return _cursorWorldPosition;\n    };\n    const GetTile = (position) => {\n        const tile = _tiles.find(tile => tile.p.x === position.x &&\n            tile.p.y === position.y &&\n            tile.p.z === position.z);\n        return tile;\n    };\n    const GetSurfaceTile = (position) => {\n        for (let z = 4; z >= 0; z--) {\n            const tile = _tiles.find(tile => tile.p.x === position.x && tile.p.y === position.y && tile.p.z === z);\n            if (tile !== undefined) {\n                return tile;\n            }\n        }\n        return undefined;\n    };\n    const GetTiles = () => {\n        return _tiles;\n    };\n    const GenerateTiles = ({ landAxialRadius = 1, worldAxialRadius = 12 } = {}) => {\n        let tiles = [];\n        const perlin1 = (0, perlin_noise_1.CreatePerlinNoise)();\n        const perlin2 = (0, perlin_noise_1.CreatePerlinNoise)();\n        const positions = [];\n        for (let y = -worldAxialRadius; y <= worldAxialRadius; y += 1) {\n            for (let x = -worldAxialRadius; x <= worldAxialRadius; x += 1) {\n                positions.push({ x, y });\n            }\n        }\n        const offset = worldAxialRadius; // Perlin noise does not like negative numbers\n        const octaves = 4;\n        for (const p of positions) {\n            let frequency = 16;\n            const n1 = perlin1.noise({\n                x: (p.x + offset) / frequency,\n                y: (p.y + offset) / frequency,\n                octaves\n            });\n            frequency = 8;\n            const n2 = perlin2.noise({\n                x: (p.x + offset) / frequency,\n                y: (p.y + offset) / frequency,\n                octaves\n            });\n            let tileType = types_1.TileType.grass;\n            const borderDistance = landAxialRadius + n2;\n            if (Math.abs(p.x) > borderDistance || Math.abs(p.y) > borderDistance) {\n                tileType = types_1.TileType.water;\n            }\n            else if (n1 < -0.2) {\n                tileType = types_1.TileType.water;\n            }\n            else if (n1 < -0.1) {\n                tileType = types_1.TileType.sand;\n            }\n            else if (n1 < 0) {\n                tileType = types_1.TileType.dirt;\n            }\n            else if (n1 < 0.2) {\n                tileType = types_1.TileType.dryGrass;\n            }\n            else if (n1 < 0.4) {\n                tileType = types_1.TileType.grass;\n            }\n            else if (n1 < 0.7) {\n                tileType = types_1.TileType.stone;\n            }\n            else if (n1 < 1.0) {\n                tileType = types_1.TileType.lava;\n            }\n            let wz = 0;\n            if (tileType === types_1.TileType.water) {\n                wz = 0;\n            }\n            else if (n1 < 0.2) {\n                wz = 0;\n            }\n            else if (n1 < 0.4) {\n                wz = 1;\n            }\n            else if (n1 < 1.0) {\n                wz = 2;\n            }\n            for (let zz = 0; zz <= wz; zz++) {\n                tiles.push({ p: { x: p.x, y: p.y, z: zz }, tileType });\n            }\n            const AddDecorativeTile = (tileType, z = 1) => {\n                tiles.push({\n                    p: { x: p.x, y: p.y, z: wz + z },\n                    tileType\n                });\n            };\n            const r = Math.random();\n            if (tileType === types_1.TileType.grass) {\n                if (r < 0.05) {\n                    AddDecorativeTile(types_1.TileType.blueOrchid);\n                }\n                else if (r < 0.1) {\n                    AddDecorativeTile(types_1.TileType.rose);\n                }\n                else if (r < 0.15) {\n                    AddDecorativeTile(types_1.TileType.log);\n                    AddDecorativeTile(types_1.TileType.canopy, 2);\n                }\n                else if (r < 0.2) {\n                    AddDecorativeTile(types_1.TileType.smallStones);\n                }\n            }\n            else if (tileType === types_1.TileType.dryGrass && r < 0.1) {\n                AddDecorativeTile(types_1.TileType.plant);\n            }\n            else if (tileType === types_1.TileType.sand) {\n                if (r < 0.1) {\n                    AddDecorativeTile(types_1.TileType.cactus);\n                }\n                else if (r < 0.15) {\n                    AddDecorativeTile(types_1.TileType.palmTree);\n                }\n            }\n            else if (tileType === types_1.TileType.stone && r > 0.95) {\n                AddDecorativeTile(types_1.TileType.largeStones);\n            }\n        }\n        _tiles = tiles;\n        const allowedLavaNeighbours = [types_1.TileType.stone, types_1.TileType.lava];\n        // only allow lava tiles which are surrounded by stone\n        for (let tile of _tiles) {\n            if (tile.tileType === types_1.TileType.lava) {\n                const neighbours = [\n                    { p: { x: 0, y: 0, z: 1 }, tileTypes: [undefined] },\n                    {\n                        p: { x: 1, y: 0, z: 0 },\n                        tileTypes: allowedLavaNeighbours\n                    },\n                    {\n                        p: { x: 0, y: 1, z: 0 },\n                        tileTypes: allowedLavaNeighbours\n                    },\n                    {\n                        p: { x: -1, y: 0, z: 0 },\n                        tileTypes: allowedLavaNeighbours\n                    },\n                    {\n                        p: { x: 0, y: -1, z: 0 },\n                        tileTypes: allowedLavaNeighbours\n                    }\n                ];\n                for (let neighbour of neighbours) {\n                    const other = GetTile({\n                        x: tile.p.x + neighbour.p.x,\n                        y: tile.p.y + neighbour.p.y,\n                        z: tile.p.z + neighbour.p.z\n                    });\n                    if (!neighbour.tileTypes.includes(other?.tileType)) {\n                        tile.tileType = types_1.TileType.stone;\n                        break;\n                    }\n                }\n            }\n        }\n        for (let tile of _tiles) {\n            if (tile.tileType === types_1.TileType.dirt) {\n                const p = {\n                    x: tile.p.x,\n                    y: tile.p.y - 1,\n                    z: tile.p.z\n                };\n                const neighbour = GetTile(p);\n                if (neighbour && [types_1.TileType.sand].includes(neighbour.tileType)) {\n                    const dirtEdge = {\n                        p,\n                        tileType: types_1.TileType.dirtFrontEdge\n                    };\n                    _tiles.push(dirtEdge);\n                }\n            }\n        }\n    };\n    return {\n        SetCursorWorldPosition,\n        GetCursorWorldPosition,\n        GetTile,\n        GetTiles,\n        GenerateTiles,\n        GetSurfaceTile\n    };\n};\nexports.CreateWorld = CreateWorld;\n\n\n//# sourceURL=webpack:///./src/front_end/world/main.ts?");

/***/ }),

/***/ "./src/front_end/world/types.ts":
/*!**************************************!*\
  !*** ./src/front_end/world/types.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TileType = void 0;\nvar TileType;\n(function (TileType) {\n    TileType[\"dirt\"] = \"dirt\";\n    TileType[\"grass\"] = \"grass\";\n    TileType[\"stone\"] = \"stone\";\n    TileType[\"sand\"] = \"sand\";\n    TileType[\"water\"] = \"water\";\n    TileType[\"plant\"] = \"plant\";\n    TileType[\"cactus\"] = \"cactus\";\n    TileType[\"log\"] = \"log\";\n    TileType[\"canopy\"] = \"canopy\";\n    TileType[\"dryGrass\"] = \"dryGrass\";\n    TileType[\"smallStones\"] = \"smallStones\";\n    TileType[\"largeStones\"] = \"largeStones\";\n    TileType[\"lava\"] = \"lava\";\n    TileType[\"blueOrchid\"] = \"blueOrchid\";\n    TileType[\"rose\"] = \"rose\";\n    TileType[\"palmTree\"] = \"palmTree\";\n    TileType[\"dirtFrontEdge\"] = \"dirtFrontEdge\";\n})(TileType || (exports.TileType = TileType = {}));\n\n\n//# sourceURL=webpack:///./src/front_end/world/types.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/front_end/main.ts");
/******/ 	
/******/ })()
;